unit uService;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.SvcMgr, Vcl.Dialogs,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf,
  FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async,
  FireDAC.Phys, FireDAC.Phys.SQLite, FireDAC.Phys.SQLiteDef,
  FireDAC.Stan.ExprFuncs, FireDAC.Phys.SQLiteWrapper.Stat, FireDAC.VCLUI.Wait,
  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB,
  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Vcl.ExtCtrls, Generics.Collections, FMX.Platform;

const
  itemPos = 1;
  itemClick = 2;
  itemSleep = 3;
  itemScroll = 4;
  itemSeparator = 5;
  itemRightClick = 6;
  itemDoubleClick = 7;
  itemCtrlA = 8;
  itemCtrlC = 9;
  itemCtrlV = 12;
  itemTranslate = 13;
  itemGetLang = 14;
  itemTab = 15;
  itemEnter = 16;
  itemText = 17;

  itemHotKey = 22;
  itemWaitWindow = 23;
  Literals: Array [0 .. 34] of char = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6',
    '7', '8', '9');

type
  TServiceForm = class(TService)
    FDConnection: TFDConnection;
    FDQuery: TFDQuery;
    Timer: TTimer;
    procedure TimerTimer(Sender: TObject);
  private
    { Private declarations }
    FScenarioList: TStrings;
    IsStarted: boolean;
    FDictinary: TDictionary<integer, string>;
    Svc: IFMXClipboardService;
    ATimer: TTimer;
    FNextItem: integer;
    OldPos: TPoint;
    WindowName: PWideChar;
    procedure StartScheduler;
    procedure ExecuteScenario(FilePath: string);
    procedure OnWaitWindow(Sender: TObject);
    procedure PostKeyEx32(key: word; const shift: TShiftState);
    procedure Start(ANext: integer = 0);
  public
    function GetServiceController: TServiceController; override;
    { Public declarations }
    constructor Create(AOwner: TComponent); overload;
  end;

var
  ServiceForm: TServiceForm;

implementation

{$R *.dfm}

procedure ServiceController(CtrlCode: DWord); stdcall;
begin
  ServiceForm.Controller(CtrlCode);
end;

constructor TServiceForm.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  TPlatformServices.Current.SupportsPlatformService(IFMXClipboardService, Svc);
  FDConnection.Params.Database := ExtractFilePAth(paramstr(0)) + '\base.db';
  FDConnection.Connected := true;
  Timer.Enabled := true;
  FScenarioList := TStrings.Create;
  FDictinary := TDictionary<integer, string>.Create;
  IsStarted := false;
end;

function TServiceForm.GetServiceController: TServiceController;
begin
  Result := ServiceController;
end;

procedure TServiceForm.TimerTimer(Sender: TObject);
begin
  FDQuery.SQL.Add('select Scenario from startlist;');
  FDQuery.Active := true;

  while NOT FDQuery.Eof do
  begin
    FScenarioList.Add(FDQuery.FieldByName('scenario').AsString);
    FDQuery.Next;
  end;

  if (FScenarioList.Count > 0) and NOT IsStarted then
    StartScheduler;
end;

procedure TServiceForm.StartScheduler;
var
  I: integer;
begin
  IsStarted := true;
  I := 0;

  while I <= FScenarioList.Count - 1 do
  begin
    ExecuteScenario(FScenarioList[I]);
    Inc(I);
  end;

  IsStarted := false;
end;

procedure TServiceForm.ExecuteScenario(FilePath: string);
var
  AFile: TStringList;
  key, I: integer;
  Value: string;
begin
  AFile := TStringList.Create;
  AFile.LoadFromFile(FilePath);

  for I := 0 to AFile.Count - 1 do
  begin
    key := StrToInt(Copy(AFile[I], 1, Pos('-', AFile[I]) - 1));
    Value := Copy(AFile[I], Pos('-', AFile[I]) + 1);
    FDictinary.Add(key, Value);
  end;

  FNextItem := 0;
  Start;
end;

procedure TServiceForm.Start(ANext: integer = 0);
var
  key, J: integer;
  tmpPoint: TPoint;
  tmpPos: string;
  s: string;
  aSS: TShiftState;
  Litter: char;
begin

  key := ANext;

  while key <= FDictinary.Count - 1 do
  begin
    sleep(500);
    case key of
      itemPos:
        begin
          tmpPoint.X := Round(StrToInt(Copy(FDictinary.Items[key], 1, Pos('-', FDictinary.Items[key]) - 1)));
          tmpPoint.Y := Round(StrToInt(Copy(FDictinary.Items[key], Pos('-', FDictinary.Items[key]) + 1)));
          OldPos := tmpPoint;
          SetCursorPos(tmpPoint.X, tmpPoint.Y);
        end;
      itemSleep:
        begin
          sleep(FDictinary.Items[key].ToInteger);
        end;
      itemClick:
        begin
          mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
          mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
        end;
      itemScroll:
        begin
          mouse_event(MOUSEEVENTF_WHEEL, 0, 0, DWord(FDictinary.Items[key].ToInteger), 0);
        end;

      itemRightClick:
        begin
          mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
          mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
        end;
      itemDoubleClick:
        begin
          mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
          mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
          mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
          mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
        end;

      itemCtrlA:
        begin
          PostKeyEx32(Ord('A'), [ssctrl]);
        end;
      itemCtrlC:
        begin
          PostKeyEx32(Ord('C'), [ssctrl]);
        end;
      itemCtrlV:
        begin
          PostKeyEx32(Ord('V'), [ssctrl]);
        end;
      itemTab:
        begin
          PostKeyEx32(9, [ssctrl]);
        end;
      itemEnter:
        begin
          PostKeyEx32(13, [ssctrl]);
        end;
      itemText:
        begin
          Svc.SetClipboard(FDictinary.Items[key]);
          PostKeyEx32(Ord('V'), [ssctrl]);
        end;
      itemHotKey:
        begin
          s := FDictinary.Items[key];

          case Copy(s, 1, 1).ToInteger of
            0:
              aSS := [ssAlt];
            1:
              aSS := [ssctrl];
            2:
              aSS := [ssShift];
            3:
              aSS := [ssAlt, ssctrl];
            4:
              aSS := [ssAlt, ssShift];
            5:
              aSS := [ssctrl, ssShift];
          end;

          Litter := Literals[Copy(s, 3).ToInteger];
          PostKeyEx32(Ord(Litter), aSS);
        end;
      itemWaitWindow:
        begin
          if ATimer <> nil then
            ATimer.Enabled := false
          else
            ATimer := TTimer.Create(nil);

          WindowName := PWideChar(FDictinary.Items[key]);
          ATimer.Enabled := false;
          ATimer.Interval := 300;
          ATimer.OnTimer := OnWaitWindow;
          ATimer.Enabled := true;
          FNextItem := key + 1;
          exit;
        end;
    end;
    Inc(key);
  end;

end;

procedure TServiceForm.OnWaitWindow(Sender: TObject);
var
  h: HWND;
begin
  h := FindWindow(nil, WindowName);
  if h <> 0 then
  begin
    ATimer.Enabled := false;
    Start(FNextItem);
  end;
end;

procedure TServiceForm.PostKeyEx32(key: word; const shift: TShiftState);

type
  TShiftKeyInfo = record
    shift: byte;
    vkey: byte;
  end;

  byteset = set of 0 .. 7;
const
  shiftkeys: array [1 .. 3] of TShiftKeyInfo = ((shift: Ord(ssctrl); vkey: VK_CONTROL), (shift: Ord(ssShift); vkey: VK_SHIFT), (shift: Ord(ssAlt); vkey: VK_MENU));
var
  flag: DWord;
  bShift: byteset absolute shift;
  I: integer;
begin
  for I := 1 to 3 do
  begin
    if shiftkeys[I].shift in bShift then
      keybd_event(shiftkeys[I].vkey, MapVirtualKey(shiftkeys[I].vkey, 0), 0, 0);
  end; { For }
  flag := 0;

  keybd_event(key, MapVirtualKey(key, 0), flag, 0);
  flag := flag or KEYEVENTF_KEYUP;
  keybd_event(key, MapVirtualKey(key, 0), flag, 0);

  for I := 3 downto 1 do
  begin
    if shiftkeys[I].shift in bShift then
      keybd_event(shiftkeys[I].vkey, MapVirtualKey(shiftkeys[I].vkey, 0), KEYEVENTF_KEYUP, 0);
  end; { For }
end; { PostKeyEx32 }

end.
